---
title: OTP Things in Elixir
date: 2020-12-17 18:35
---
In Elixir, a thread is just a function passed into the spawn method. That function executes. In that function, you can call receive and then that thread is blocked until it receives a message and execures. To make a thread a server, you just recurse, waiting for a message, doing something for the message then calling the function to receive another message again. If there is state, then that state passed on to the recursion stack as arguments. When a thread fails it stops. But there is a way for a spawning thread to get notified about fails. That is what is called start link. All this is enough to implement with hand what OTP provides. But these OTP modules do write a lot of boilerplate and extra useful utilities. There is gen server that requires a few implementations of interface methods lie receive calls and receive cast. A gen server implemetation is designed to have client method and private methods. The client methods are for calling from outside. That sends the message. So the message structure is contained inside the module. It is used as a mixin. When you call start link, you usually use the module name for registering. PID is used a lot. PID has to be maintained if not registered with module name in which case there is only a single instance. Superviser is another kind of module. It can start a lot of genserver. It can be made to do routing - maybe even smart routing. There are strategies on how to restart and what to restart. Besides GenServer and Superviser, there is Agent whose job is to simply hold state. There is also something called Job of Task. All run inside a BEAM instance. A BEAM instance can span multiple machines. It is all message passing and immutability. There is no type. But atoms play a big part.